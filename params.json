{"name":"node-fluent-ffmpeg","body":"This library abstracts the complex command-line usage of ffmpeg into a fluent, easy to use node.js module. In order to be able to use this module, make sure you have [ffmpeg](http://www.ffmpeg.org) installed on your system (including all necessary encoding libraries like libmp3lame or libx264).\r\n\r\nContributions in any form are highly encouraged and appreciated! Be it new or improved presets, optimized streaming code or just some cleanup. So start forking!\r\n\r\n##Table of contents\r\n\r\n* [Installation / Tests](#installation)\r\n* [Usage](#basic-usage)\r\n  * [Basic conversion using API](#basic-conversion-api)\r\n  * [Using presets](#conversion-preset)\r\n  * [Tracking Progress](#progress)\r\n  * [Taking screenshots](#screenshots)\r\n* [Advanced usage](#advanced-usage)\r\n  * [Auto-Padding](#auto-padding)\r\n  * [Auto-Sizing](#auto-sizing)\r\n  * [Streaming](#streaming)\r\n  * [Metadata](#metadata)\r\n\r\n## Installation<a id=\"installation\" />\r\nVia npm:\r\n`$ npm install fluent-ffmpeg`\r\n\r\nOr as a submodule:\r\n`$ git submodule add git://github.com/schaermu/node-fluent-ffmpeg.git vendor/fluent-ffmpeg`\r\n## Tests\r\nTo run unit tests, make sure have nodeunit installed on your system (is registered as a development dependency in package.json).\r\n\r\n`$ npm test`\r\n\r\nMake sure your ffmpeg installation is up-to-date to prevent strange assertion errors because of missing codecs/bugfixes.\r\n## Usage<a id=\"basic-usage\" />\r\nYou find a lot of usage examples (including a real-time streaming example using [flowplayer](http://www.flowplayer.org) and [express](https://github.com/visionmedia/express)!) in the `examples` folder.\r\n### Conversion using chainable API<a id=\"basic-conversion-api\" />\r\nUsing the chainable API, you are able to perform any operation using FFMPEG. the most common options are implemented using methods, for more advanced usages you can still use the `addOption(s)` method group.\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n    \r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .withVideoBitrate(1024)\r\n      .withVideoCodec('divx')\r\n      .withAspect('16:9')\r\n      .withFps(24)\r\n      .withAudioBitrate('128k')\r\n      .withAudioCodec('libmp3lame')\r\n      .withAudioChannels(2)\r\n      .addOption('-vtag', 'DIVX')\r\n      .toFormat('avi')\r\n      .saveToFile('/path/to/your_target.avi', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\n\r\n### Conversion using preset<a id=\"conversion-preset\" />\r\nThis example loads up a predefined preset in the preset folder (currently, fluent-ffmpeg ships with presets for DIVX, Flashvideo and Podcast conversions)\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n\r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .usingPreset('podcast')\r\n      .saveToFile('/path/to/your_target.m4v', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\n\r\n### Tracking progress of conversion<a id=\"progress\" />\r\nYou can set the callback onProgress if you want to be notified on every progress update (triggered as fast as it's written out by FFMPEG).\r\n\r\n    var proc = new ffmpeg({ source: '/path/to/your_movie.avi' })\r\n      .withAspect('4:3')\r\n      .withSize('640x480')\r\n      .onProgress(function(progress) {\r\n        console.log(progress);\r\n      })\r\n      .saveToFile('/path/to/your_target.avi', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\n\r\nThe progress object consists of 6 properties:\r\n\r\n  * `frames` - the total processed frame count\r\n  * `currentFps` - the framerate at which FFMPEG is currently processing the file\r\n  * `currentKbps` - the throughput at which FFMPEG is currently processing the file\r\n  * `targetSize` - the current size of the target file\r\n  * `timemark` - the timestamp of the frame being processed right now\r\n  * `percent` - an estimation on the progress (metadata is used, durationsec * fps)\r\n\r\n### Creating thumbnails from a video file<a id=\"screenshots\" />\r\nOne pretty neat feature is the ability of fluent-ffmpeg to generate any amount of thumbnails from your movies. The screenshots are taken at automatically determined timemarks using the following formula: `(duration_in_sec * 0.9) / number_of_thumbnails`.\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n    \r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .withSize('150x100')\r\n      .takeScreenshots(5, '/path/to/thumbnail/folder', function(err) {\r\n        console.log('screenshots were saved')\r\n      });\r\n\r\nFor more control, you can also set the timemarks for taking screenshots yourself (timemarks are always in seconds):\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n    \r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .withSize('150x100')\r\n      .takeScreenshots({\r\n          count: 2,\r\n          timemarks: [ '0.5', '1' ]\r\n        }, '/path/to/thumbnail/folder', function(err) {\r\n        console.log('screenshots were saved')\r\n      });\r\n\r\n## Advanced usage<a id=\"advanced-usage\" />\r\n### Auto-calculation of video dimensions<a id=\"auto-sizing\" />\r\nSince ffmpeg does not support dynamic sizing of your movies, fluent-ffmpeg can do this job for you (using it's internal metadata-discovery). The following size formats are allowed to be passed to `withSize`:\r\n\r\n  * `320x?` - Fixed width, calculate height\r\n  * `?x240` - Fixed height, calculate width\r\n  * `50%` - percental resizing\r\n  * `320x240` - fixed size (plain ffmpeg way)\r\n\r\n### Auto-padding when converting aspect ratio<a id=\"auto-padding\" />\r\nUsing fluent-ffmpeg, you can auto-pad any video output when converting the aspect ratio. When converting from 4:3 to 16:9, padding is added to the left/right, when converting from 16:9 to 4:3, padding is added to top/bottom.\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n\r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .withAspect('4:3')\r\n      .withSize('640x480')\r\n      .applyAutopadding(true, 'white')\r\n      .saveToFile('/path/to/your_target.avi', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\nThis command will auto-pad your 4:3 output video stream using a white background-color (default is black).\r\n### Reading video metadata\r\nUsing a seperate object, you are able to access various metadata of your video file.\r\n\r\n    var ffmpegmeta = require('fluent-ffmpeg').Metadata;\r\n    \r\n    // make sure you set the correct path to your video file\r\n    ffmpegmeta.get('/path/to/your_movie.avi', function(metadata) {\r\n      console.log(require('util').inspect(metadata, false, null));\r\n    });\r\n### Streaming<a id=\"streaming\" />\r\nUsing direct streaming, you can implement a basic VOD-server with just a couple of lines using node-fluent-ffmpeg and express:\r\n\r\n    var express = require('express'),\r\n      ffmpeg = require('../lib/fluent-ffmpeg');\r\n\r\n    var app = express.createServer();\r\n\r\n    app.use(express.static(__dirname + '/flowplayer'));\r\n\r\n    app.get('/', function(req, res) {\r\n      res.send('index.html');\r\n    });\r\n\r\n    app.get('/video/:filename', function(req, res) {\r\n      res.contentType('flv');\r\n      // make sure you set the correct path to your video file storage\r\n      var pathToMovie = '/path/to/storage/' + req.params.filename; \r\n      var proc = new ffmpeg(pathToMovie)\r\n        // use the 'flashvideo' preset (located in /lib/presets/flashvideo.js)\r\n        .usingPreset('flashvideo')\r\n        // save to stream\r\n        .writeToStream(res, function(retcode, error){\r\n          console.log('file has been converted succesfully');\r\n        });\r\n    });\r\n\r\nThe prossibilities of adding conversion parameters to the HTTP-request were not even closely touched here.\r\n\r\napp.listen(4000);\r\n\r\n### Reading Codec information while processing\r\nUsing the notification callback onCodecData, you can get informations about the input file's codecs being processed:\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n\r\n    var proc = new ffmpeg('/path/to/your_movie.avi')\r\n      .withAspect('4:3')\r\n      .withSize('640x480')\r\n      .onCodecData(function(codecinfo) {\r\n        console.log(codecinfo);\r\n      })\r\n      .saveToFile('/path/to/your_target.avi', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\n## Additional stuff\r\n### Creating a custom preset\r\nTo create a custom preset, you have to create a new file inside the `lib/presets` folder. The filename is used as the preset's name ([presetname].js). In order to make the preset work, you have to export a `load` function using the CommonJS module specifications:\r\n\r\n    exports.load = function(ffmpeg) {\r\n      // your custom preset code\r\n    }\r\n\r\nThe `ffmpeg` parameter is a full fluent-ffmpeg object, you can use all the chaining-goodness from here on. For a good example for the possibilities using presets, check out `lib/presets/podcast.js`.\r\n\r\n\r\n### Setting custom child process niceness\r\nYou can adjust the scheduling priority of the child process used by ffmpeg, using renice (http://manpages.ubuntu.com/manpages/intrepid/man1/renice.1.html):\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n    \r\n    var proc = new ffmpeg('./source.mp3')\r\n      .renice(10)\r\n      .withAudioCodec('libvorbis')\r\n      .toFormat('ogg')\r\n      .saveToFile('./target.ogg', function(retcode, error) {\r\n        console.log('file has been converted succesfully');\r\n      });\r\n\r\nWhich will use a niceness of 10 (thus it has a lower scheduling priority than the node process and other processes, which default to a niceness of 0).\r\n\r\n### Setting an optional processing timeout\r\nIf you want to know for sure that the ffmpeg child process will not run for longer than a certain amount of time, you can set the optional second parameter of the ffmpeg object constructor to the timeout in milliseconds. An example of a process that will return an error string of 'timeout' if ffmpeg did not finish within 10 minutes:\r\n\r\n    var ffmpeg = require('fluent-ffmpeg');\r\n    \r\n    var proc = new ffmpeg('./source.mp3', 10 * 60 * 1000)\r\n      .withAudioCodec('libvorbis')\r\n      .toFormat('ogg')\r\n      .saveToFile('./target.ogg', function(retcode, error) {\r\n        if (retcode == ffmpeg.E_PROCESSTIMEOUT) {\r\n          console.log('ffmpeg terminated because of timeout');\r\n        }\r\n      });","tagline":"A fluent API to FFMPEG for node.js","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}