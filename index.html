<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="node-fluent-ffmpeg : A fluent API to FFMPEG for node.js" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>node-fluent-ffmpeg</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/schaermu/node-fluent-ffmpeg">Fork Me on GitHub</a>

          <h1 id="project_title">node-fluent-ffmpeg</h1>
          <h2 id="project_tagline">A fluent API to FFMPEG for node.js</h2>

          <section id="downloads">
            <a class="zip_download_link" href="https://github.com/schaermu/node-fluent-ffmpeg/zipball/master">Download this project as a .zip file</a>
            <a class="tar_download_link" href="https://github.com/schaermu/node-fluent-ffmpeg/tarball/master">Download this project as a tar.gz file</a>
          </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>This library abstracts the complex command-line usage of ffmpeg into a fluent, easy to use node.js module. In order to be able to use this module, make sure you have <a href="http://www.ffmpeg.org">ffmpeg</a> installed on your system (including all necessary encoding libraries like libmp3lame or libx264).</p>

<p>Contributions in any form are highly encouraged and appreciated! Be it new or improved presets, optimized streaming code or just some cleanup. So start forking!</p>

<h2>Table of contents</h2>

<ul>
<li><a href="#installation">Installation / Tests</a></li>
<li>
<a href="#basic-usage">Usage</a>

<ul>
<li><a href="#basic-conversion-api">Basic conversion using API</a></li>
<li><a href="#conversion-preset">Using presets</a></li>
<li><a href="#progress">Tracking Progress</a></li>
<li><a href="#screenshots">Taking screenshots</a></li>
</ul>
</li>
<li>
<a href="#advanced-usage">Advanced usage</a>

<ul>
<li><a href="#auto-padding">Auto-Padding</a></li>
<li><a href="#auto-sizing">Auto-Sizing</a></li>
<li><a href="#streaming">Streaming</a></li>
<li><a href="#metadata">Metadata</a></li>
</ul>
</li>
</ul><h2>Installation<a></a>
</h2>

<p>Via npm:
<code>$ npm install fluent-ffmpeg</code></p>

<p>Or as a submodule:
<code>$ git submodule add git://github.com/schaermu/node-fluent-ffmpeg.git vendor/fluent-ffmpeg</code></p>

<h2>Tests</h2>

<p>To run unit tests, make sure have nodeunit installed on your system (is registered as a development dependency in package.json).</p>

<p><code>$ npm test</code></p>

<p>Make sure your ffmpeg installation is up-to-date to prevent strange assertion errors because of missing codecs/bugfixes.</p>

<h2>Usage<a></a>
</h2>

<p>You find a lot of usage examples (including a real-time streaming example using <a href="http://www.flowplayer.org">flowplayer</a> and <a href="https://github.com/visionmedia/express">express</a>!) in the <code>examples</code> folder.</p>

<h3>Conversion using chainable API<a></a>
</h3>

<p>Using the chainable API, you are able to perform any operation using FFMPEG. the most common options are implemented using methods, for more advanced usages you can still use the <code>addOption(s)</code> method group.</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .withVideoBitrate(1024)
  .withVideoCodec('divx')
  .withAspect('16:9')
  .withFps(24)
  .withAudioBitrate('128k')
  .withAudioCodec('libmp3lame')
  .withAudioChannels(2)
  .addOption('-vtag', 'DIVX')
  .toFormat('avi')
  .saveToFile('/path/to/your_target.avi', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<h3>Conversion using preset<a></a>
</h3>

<p>This example loads up a predefined preset in the preset folder (currently, fluent-ffmpeg ships with presets for DIVX, Flashvideo and Podcast conversions)</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .usingPreset('podcast')
  .saveToFile('/path/to/your_target.m4v', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<h3>Tracking progress of conversion<a></a>
</h3>

<p>You can set the callback onProgress if you want to be notified on every progress update (triggered as fast as it's written out by FFMPEG).</p>

<pre><code>var proc = new ffmpeg({ source: '/path/to/your_movie.avi' })
  .withAspect('4:3')
  .withSize('640x480')
  .onProgress(function(progress) {
    console.log(progress);
  })
  .saveToFile('/path/to/your_target.avi', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<p>The progress object consists of 6 properties:</p>

<ul>
<li>
<code>frames</code> - the total processed frame count</li>
<li>
<code>currentFps</code> - the framerate at which FFMPEG is currently processing the file</li>
<li>
<code>currentKbps</code> - the throughput at which FFMPEG is currently processing the file</li>
<li>
<code>targetSize</code> - the current size of the target file</li>
<li>
<code>timemark</code> - the timestamp of the frame being processed right now</li>
<li>
<code>percent</code> - an estimation on the progress (metadata is used, durationsec * fps)</li>
</ul><h3>Creating thumbnails from a video file<a></a>
</h3>

<p>One pretty neat feature is the ability of fluent-ffmpeg to generate any amount of thumbnails from your movies. The screenshots are taken at automatically determined timemarks using the following formula: <code>(duration_in_sec * 0.9) / number_of_thumbnails</code>.</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .withSize('150x100')
  .takeScreenshots(5, '/path/to/thumbnail/folder', function(err) {
    console.log('screenshots were saved')
  });
</code></pre>

<p>For more control, you can also set the timemarks for taking screenshots yourself (timemarks are always in seconds):</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .withSize('150x100')
  .takeScreenshots({
      count: 2,
      timemarks: [ '0.5', '1' ]
    }, '/path/to/thumbnail/folder', function(err) {
    console.log('screenshots were saved')
  });
</code></pre>

<h2>Advanced usage<a></a>
</h2>

<h3>Auto-calculation of video dimensions<a></a>
</h3>

<p>Since ffmpeg does not support dynamic sizing of your movies, fluent-ffmpeg can do this job for you (using it's internal metadata-discovery). The following size formats are allowed to be passed to <code>withSize</code>:</p>

<ul>
<li>
<code>320x?</code> - Fixed width, calculate height</li>
<li>
<code>?x240</code> - Fixed height, calculate width</li>
<li>
<code>50%</code> - percental resizing</li>
<li>
<code>320x240</code> - fixed size (plain ffmpeg way)</li>
</ul><h3>Auto-padding when converting aspect ratio<a></a>
</h3>

<p>Using fluent-ffmpeg, you can auto-pad any video output when converting the aspect ratio. When converting from 4:3 to 16:9, padding is added to the left/right, when converting from 16:9 to 4:3, padding is added to top/bottom.</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .withAspect('4:3')
  .withSize('640x480')
  .applyAutopadding(true, 'white')
  .saveToFile('/path/to/your_target.avi', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<p>This command will auto-pad your 4:3 output video stream using a white background-color (default is black).</p>

<h3>Reading video metadata</h3>

<p>Using a seperate object, you are able to access various metadata of your video file.</p>

<pre><code>var ffmpegmeta = require('fluent-ffmpeg').Metadata;

// make sure you set the correct path to your video file
ffmpegmeta.get('/path/to/your_movie.avi', function(metadata) {
  console.log(require('util').inspect(metadata, false, null));
});
</code></pre>

<h3>Streaming<a></a>
</h3>

<p>Using direct streaming, you can implement a basic VOD-server with just a couple of lines using node-fluent-ffmpeg and express:</p>

<pre><code>var express = require('express'),
  ffmpeg = require('../lib/fluent-ffmpeg');

var app = express.createServer();

app.use(express.static(__dirname + '/flowplayer'));

app.get('/', function(req, res) {
  res.send('index.html');
});

app.get('/video/:filename', function(req, res) {
  res.contentType('flv');
  // make sure you set the correct path to your video file storage
  var pathToMovie = '/path/to/storage/' + req.params.filename; 
  var proc = new ffmpeg(pathToMovie)
    // use the 'flashvideo' preset (located in /lib/presets/flashvideo.js)
    .usingPreset('flashvideo')
    // save to stream
    .writeToStream(res, function(retcode, error){
      console.log('file has been converted succesfully');
    });
});
</code></pre>

<p>The prossibilities of adding conversion parameters to the HTTP-request were not even closely touched here.</p>

<p>app.listen(4000);</p>

<h3>Reading Codec information while processing</h3>

<p>Using the notification callback onCodecData, you can get informations about the input file's codecs being processed:</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('/path/to/your_movie.avi')
  .withAspect('4:3')
  .withSize('640x480')
  .onCodecData(function(codecinfo) {
    console.log(codecinfo);
  })
  .saveToFile('/path/to/your_target.avi', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<h2>Additional stuff</h2>

<h3>Creating a custom preset</h3>

<p>To create a custom preset, you have to create a new file inside the <code>lib/presets</code> folder. The filename is used as the preset's name ([presetname].js). In order to make the preset work, you have to export a <code>load</code> function using the CommonJS module specifications:</p>

<pre><code>exports.load = function(ffmpeg) {
  // your custom preset code
}
</code></pre>

<p>The <code>ffmpeg</code> parameter is a full fluent-ffmpeg object, you can use all the chaining-goodness from here on. For a good example for the possibilities using presets, check out <code>lib/presets/podcast.js</code>.</p>

<h3>Setting custom child process niceness</h3>

<p>You can adjust the scheduling priority of the child process used by ffmpeg, using renice (<a href="http://manpages.ubuntu.com/manpages/intrepid/man1/renice.1.html):">http://manpages.ubuntu.com/manpages/intrepid/man1/renice.1.html):</a></p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('./source.mp3')
  .renice(10)
  .withAudioCodec('libvorbis')
  .toFormat('ogg')
  .saveToFile('./target.ogg', function(retcode, error) {
    console.log('file has been converted succesfully');
  });
</code></pre>

<p>Which will use a niceness of 10 (thus it has a lower scheduling priority than the node process and other processes, which default to a niceness of 0).</p>

<h3>Setting an optional processing timeout</h3>

<p>If you want to know for sure that the ffmpeg child process will not run for longer than a certain amount of time, you can set the optional second parameter of the ffmpeg object constructor to the timeout in milliseconds. An example of a process that will return an error string of 'timeout' if ffmpeg did not finish within 10 minutes:</p>

<pre><code>var ffmpeg = require('fluent-ffmpeg');

var proc = new ffmpeg('./source.mp3', 10 * 60 * 1000)
  .withAudioCodec('libvorbis')
  .toFormat('ogg')
  .saveToFile('./target.ogg', function(retcode, error) {
    if (retcode == ffmpeg.E_PROCESSTIMEOUT) {
      console.log('ffmpeg terminated because of timeout');
    }
  });
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">node-fluent-ffmpeg maintained by <a href="https://github.com/schaermu">schaermu</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
